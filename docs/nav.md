# Обзор

Плагин реализующий навигацию по элементам с помощью ПДУ или клавиатуры. Позволяет создавать интерфейсы с изменяющимся содержимым.
Основные фичи:
1) автоматическое определение элемента, на который перемещается фокус для заданного направления, не нужно писать сложную логику для перехода от одного элемента к другому или задавать их вручную;
2) не нужно заботится как обработать случай когда какой-то элемент интерфейса окажется скрытым, невидимые элементы просто игнорируются;
3) создает прослойку для события keydown - nav_key. Таким образом, что nav_key становится уникальным для каждой кнопки:

```
$('.button').on('nav_key:red', function(){
   //при нажатии на красную кнопку на пульте выполнится эта функция
});
```

4) так же для нового события nav_key работает event bubbling что позволяет ловить события на нужном уровне, отменять и слушать нажатия только там где это нужно в данный момент.

# Как использовать

В HTML надо элементы которые будут помечены классом =nav_target=. Это задает элементы по которым может осуществляться навигация и эти элементы могут получать фокус.
```
<body>
    <div class="nav_target">hello</div>
    <div class="nav_target">world</div>
</body>
```
После вызова =nav.on()= к первому элементу будет добавлен класс =focus= и навигация будет активирована. Нажатие стрелок на клавиатуре или ПДУ будет перемещать фокус, клавиша enter будет эмулировать клик по элементу, а наведение мыши будет переводить элементы в фокус. Таким образом поддержка жестов в телевизоре не требует дополнительной работы, а код приложения не сильно будет отличаться от обычного сайта.
```
//отлавливаем одновременно нажатие enter и простой клик
$('.nav_target').click(function(){
    alert(this.innerHTML);
});
```
# on, off, save, restore
Удобная связка методов для того чтобы направить плагин в нужную область и вернуться обратно.
Распространенный случай: попап с сообщением.
В исходном положении фокус находится на кнопке. После нажатия на кнопку должен показаться попап, фокус переходит туда и фокус не должен выходить за пределы попапа. Но видимых =nav_target= элементов уже несколько и чтобы они не конфликтовали плагину можно задать текущую рабочую область. Делается это с помощью метода =nav.on(jQuery_selector)=, где =jQuery_selector= это все что может принять в себя функция =$= и означает новую активную область, где будет производится поиск элементов =nav_target=.  =nav.on()= содержит в себе =nav.off()= и автоматически делает неактивной предыдущую область.
```
<div class="page">
     <div class="open_popup_button button nav_target">Open</div>
</div>
<div class="overlay" style="display: none;"> <!-- Изначально попап скрыт -->
    <div class="popup">
         <div class="close_popup_button button nav_target">Close</div>
    </div>
</div>
```
```
$(function(){
    var $overlay=$(".overlay");

    nav.on(".page"); //первоначальная инициализация
    //теперь фокус на .open_popup_button

    $(".open_popup_button").click(function(){
        $overlay.show();
        nav.save(); //сохраняет текущую область и фокус
        nav.on($overlay);//переносит навигацию в новую область(попап) и выставляет новый фокус
        //теперь фокус на .close_popup_button
    });

    $(".close_popup_button").click(function(){
        $overlay.hide();
        nav.restore(); //восстанавливает предыдущее сохраненное состояние
        //теперь фокус на .open_popup_button
    });
});
```
Функции =save= и =restore= работают как =push= и =pop= для стека. Таким образом можно иметь бесконечную историю состояний.